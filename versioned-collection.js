// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Meteor._MongoCollection = Meteor.Collection;

  Meteor.Collection = (function(_super) {

    __extends(Collection, _super);

    function Collection(name, options) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      Collection.__super__.constructor.call(this, name, options);
      this._versioned = options.versioned != null ? options.versioned : false;
      if (!this._versioned) {
        return this;
      }
      this._propSpec = options.props != null ? options.props : {};
      this._crdts = new Meteor._MongoCollection("_" + name + "Crdts");
      if (Meteor.isServer) {
        this._crdts._ensureIndex({
          crdtId: 1
        });
      }
      _.each(['insert', 'update', 'remove'], function(method) {
        _this["_" + method] = _this[method];
        return delete _this[method];
      });
      this._tx = Meteor.tx;
      this._tx._addCollection(this);
      this.insertOne = function(object) {
        var id;
        if (object._id != null) {
          id = object._id;
          delete object._id;
        } else {
          id = Meteor.uuid();
        }
        this._tx._addOperation({
          op: 'insertObject',
          collection: this._name,
          crdtId: id,
          args: {
            object: object
          }
        });
        return id;
      };
      this.removeOne = function(id) {
        this._tx._addOperation({
          op: 'removeObject',
          collection: this._name,
          crdtId: id
        });
        return id;
      };
      this.setProperty = function(id, key, value) {
        this._tx._addOperation({
          op: 'insertProperty',
          collection: this._name,
          crdtId: id,
          args: {
            key: key,
            value: value
          }
        });
        return id;
      };
      this.unsetProperty = function(id, key, locator) {
        var args;
        if (locator == null) {
          locator = null;
        }
        args = {
          key: key
        };
        if (locator != null) {
          args.locator = locator;
        }
        this._tx._addOperation({
          op: 'removeProperty',
          collection: this._name,
          crdtId: id,
          args: args
        });
        return id;
      };
      if (Meteor.isServer) {
        this.reset = function() {
          this._remove({});
          this._crdts.remove({});
          return true;
        };
      }
      this._findCrdt = function(crdtId) {
        return this._crdts.findOne({
          crdtId: crdtId
        });
      };
      this._updatedCrdts = void 0;
      this._txRunning = function() {
        return this._updatedCrdts != null;
      };
      this._txStart = function() {
        console.assert(!this._txRunning(), 'Trying to start an already running transaction.');
        this._updatedCrdts = [];
        return true;
      };
      this._txCommit = function() {
        var crdt, crdtId, mongoId, newSnapshot, oldSnapshot, serializedCrdt, _i, _len, _ref;
        console.assert(this._txRunning(), 'Trying to commit a non-existent transaction.');
        _ref = this._updatedCrdts;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          mongoId = _ref[_i];
          serializedCrdt = this._crdts.findOne({
            _id: mongoId
          });
          console.assert(serializedCrdt != null);
          crdt = new Meteor._CrdtDocument(this._propSpec, serializedCrdt);
          crdtId = crdt.crdtId;
          newSnapshot = crdt.snapshot();
          oldSnapshot = this.findOne({
            _id: crdtId
          });
          if ((newSnapshot != null) && !(oldSnapshot != null)) {
            this._insert(newSnapshot);
          }
          if ((newSnapshot != null) && (oldSnapshot != null)) {
            this._update({
              _id: crdtId
            }, newSnapshot);
          }
          if ((oldSnapshot != null) && !(newSnapshot != null)) {
            this._remove({
              _id: crdtId
            });
          }
        }
        this._updatedCrdts = void 0;
        return true;
      };
      this._txAbort = function() {
        return this._updatedCrdts = void 0;
      };
      this._ops = {
        insertObject: function(crdtId, args, clock) {
          var crdt, entry, key, mongoId, serializedCrdt, value, _i, _len, _ref;
          console.assert(_this._txRunning(), 'Trying to execute operation "insertObject" outside a transaction.');
          serializedCrdt = _this._findCrdt(crdtId);
          if (serializedCrdt != null) {
            if (!serializedCrdt.deleted) {
              Meteor.log["throw"]('crdt.tryingToUndeleteVisibleCrdt', {
                collection: _this._name,
                crdtId: crdtId
              });
            }
            _this._crdts.update({
              crdtId: crdtId
            }, {
              $set: {
                deleted: false,
                clock: clock
              }
            });
            mongoId = serializedCrdt._id;
          } else {
            crdt = new Meteor._CrdtDocument(_this._propSpec);
            crdt.crdtId = crdtId;
            crdt.clock = clock;
            _ref = args.object;
            for (key in _ref) {
              value = _ref[key];
              if (_.isArray(value)) {
                for (_i = 0, _len = value.length; _i < _len; _i++) {
                  entry = value[_i];
                  crdt.append({
                    key: key,
                    value: entry
                  });
                }
              } else {
                crdt.append({
                  key: key,
                  value: value
                });
              }
            }
            mongoId = _this._crdts.insert(crdt.serialize());
          }
          _this._updatedCrdts.push(mongoId);
          return crdtId;
        },
        removeObject: function(crdtId, args, clock) {
          var serializedCrdt;
          console.assert(_this._txRunning(), 'Trying to execute operation "removeObject" outside a transaction.');
          serializedCrdt = _this._findCrdt(crdtId);
          if (serializedCrdt == null) {
            Meteor.log["throw"]('crdt.tryingToDeleteNonexistentCrdt', {
              collection: _this._name,
              crdtId: crdtId
            });
          }
          if (serializedCrdt.deleted) {
            Meteor.log["throw"]('crdt.tryingToDeleteCrdtTwice', {
              collection: _this._name,
              crdtId: crdtId
            });
          }
          _this._crdts.update({
            crdtId: crdtId
          }, {
            $set: {
              deleted: true,
              clock: clock
            }
          });
          _this._updatedCrdts.push(serializedCrdt._id);
          return crdtId;
        },
        insertProperty: function(crdtId, args, clock) {
          var crdt, index, serializedCrdt;
          console.assert(_this._txRunning(), 'Trying to execute operation "insertProperty" outside a transaction.');
          serializedCrdt = _this._findCrdt(crdtId);
          if (serializedCrdt == null) {
            Meteor.log["throw"]('crdt.tryingToInsertValueIntoNonexistentCrdt', {
              key: args.key,
              collection: _this._name,
              crdtId: crdtId
            });
          }
          crdt = new Meteor._CrdtDocument(_this._propSpec, serializedCrdt);
          index = crdt.append({
            key: args.key,
            value: args.value
          });
          _this._crdts.update({
            crdtId: crdtId
          }, {
            $set: {
              properties: crdt.serialize().properties,
              clock: clock
            }
          });
          _this._updatedCrdts.push(serializedCrdt._id);
          return index;
        },
        removeProperty: function(crdtId, args, clock) {
          var crdt, deletedIndices, locator, serializedCrdt;
          locator = null;
          if (args.locator != null) {
            locator = args.locator;
          }
          console.assert(_this._txRunning(), 'Trying to execute operation "removeProperty" outside a transaction.');
          serializedCrdt = _this._findCrdt(crdtId);
          if (serializedCrdt == null) {
            Meteor.log["throw"]('crdt.tryingToDeleteValueFromNonexistentCrdt', {
              key: args.key,
              locator: locator,
              collection: _this._name,
              crdtId: crdtId
            });
          }
          crdt = new Meteor._CrdtDocument(_this._propSpec, serializedCrdt);
          deletedIndices = crdt["delete"](args.key, locator);
          _this._crdts.update({
            crdtId: crdtId
          }, {
            $set: {
              properties: crdt.serialize().properties,
              clock: clock
            }
          });
          _this._updatedCrdts.push(serializedCrdt._id);
          return deletedIndices;
        },
        inverse: function(crdtId, args, clock) {
          var crdt, deletedIndex, origArgs, origOp, origResult, serializedCrdt, undeletedIndices;
          origOp = args.op, origArgs = args.args, origResult = args.result;
          switch (origOp) {
            case 'insertObject':
              return _this._ops.removeObject(crdtId, {}, clock);
            case 'removeObject':
              console.assert(_this._txRunning(), 'Trying to execute operation ' + '"inverse(removeObject)" outside a transaction.');
              serializedCrdt = _this._findCrdt(crdtId);
              if (serializedCrdt == null) {
                Meteor.log["throw"]('crdt.tryingToUndeleteNonexistentCrdt', {
                  collection: _this._name,
                  crdtId: crdtId
                });
              }
              if (!serializedCrdt.deleted) {
                Meteor.log.warning('crdt.tryingToUndeleteVisibleCrdt', {
                  collection: _this._name,
                  crdtId: crdtId
                });
              }
              _this._crdts.update({
                crdtId: crdtId
              }, {
                $set: {
                  deleted: false,
                  clock: clock
                }
              });
              _this._updatedCrdts.push(serializedCrdt._id);
              return true;
            case 'insertProperty':
              console.assert(_this._txRunning(), 'Trying to execute operation ' + '"inverse(insertProperty)" outside a transaction.');
              serializedCrdt = _this._findCrdt(crdtId);
              if (serializedCrdt == null) {
                Meteor.log["throw"]('crdt.tryingToDeleteValueFromNonexistentCrdt', {
                  key: origArgs.key,
                  locator: origResult,
                  collection: _this._name,
                  crdtId: crdtId
                });
              }
              crdt = new Meteor._CrdtDocument(_this._propSpec, serializedCrdt);
              deletedIndex = crdt.deleteIndex(origResult, origArgs.key);
              _this._crdts.update({
                crdtId: crdtId
              }, {
                $set: {
                  properties: crdt.serialize().properties,
                  clock: clock
                }
              });
              _this._updatedCrdts.push(serializedCrdt._id);
              return deletedIndex;
            case 'removeProperty':
              console.assert(_this._txRunning(), 'Trying to execute operation ' + '"inverse(removeProperty)" outside a transaction.');
              serializedCrdt = _this._findCrdt(crdtId);
              if (serializedCrdt == null) {
                Meteor.log["throw"]('crdt.tryingToUndeleteValueFromNonexistentCrdt', {
                  key: origArgs.key,
                  locator: origResult[0],
                  collection: _this._name,
                  crdtId: crdtId
                });
              }
              crdt = new Meteor._CrdtDocument(_this._propSpec, serializedCrdt);
              undeletedIndices = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = origResult.length; _i < _len; _i++) {
                  deletedIndex = origResult[_i];
                  _results.push(crdt.undeleteIndex(deletedIndex, origArgs.key));
                }
                return _results;
              })();
              _this._crdts.update({
                crdtId: crdtId
              }, {
                $set: {
                  properties: crdt.serialize().properties,
                  clock: clock
                }
              });
              _this._updatedCrdts.push(serializedCrdt._id);
              return undeletedIndices;
            default:
              return Meteor.log["throw"]('crdt.cannotInvert', {
                op: origOp
              });
          }
        }
      };
    }

    return Collection;

  })(Meteor._MongoCollection);

}).call(this);
