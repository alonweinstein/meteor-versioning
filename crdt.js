// Generated by CoffeeScript 1.4.0
(function() {

  Meteor._CrdtDocument = (function() {

    function _CrdtDocument(collProps, serializedCrdt) {
      this.collProps = collProps != null ? collProps : null;
      if (serializedCrdt == null) {
        serializedCrdt = null;
      }
      if (serializedCrdt != null) {
        this.crdtId = serializedCrdt.crdtId, this.clock = serializedCrdt.clock, this._properties = serializedCrdt.properties, this._deleted = serializedCrdt.deleted;
      } else {
        this.crdtId = void 0;
        this.clock = {};
        this._properties = [];
        this._deleted = false;
      }
    }

    _CrdtDocument.prototype.append = function(payload, site) {
      var property;
      property = {
        deleted: false,
        payload: payload
      };
      this._properties.push(property);
      return this._properties.length - 1;
    };

    _CrdtDocument.prototype["delete"] = function(key, locator) {
      var delProp, delProps, _i, _len, _ref, _ref1, _results,
        _this = this;
      if (locator == null) {
        locator = null;
      }
      if ((locator != null) && ((_ref = this.collProps[key]) != null ? _ref.type : void 0) === '[{}]') {
        delProps = _.filter(this._properties, function(property) {
          return property.payload.key === key && property.payload.value[_this.collProps[key].locator] === locator && !property.deleted;
        });
      } else {
        delProps = _.filter(this._properties, function(property) {
          return property.payload.key === key && !property.deleted;
        });
      }
      if ((locator != null) && ((_ref1 = this.collProps[key]) != null ? _ref1.type : void 0) === '[*]') {
        if (!((0 <= locator && locator < delProps.length))) {
          Meteor.log["throw"]('crdt.tryingToDeleteNonexistentKeyAtPos', {
            key: key,
            pos: locator,
            crdtId: this.crdtId
          });
        }
        delProps[locator].deleted = true;
        return [_.indexOf(this._properties, delProps[locator])];
      } else {
        if (delProps.length === 0) {
          Meteor.log.warning('crdt.tryingToDeleteNonexistentKey', {
            key: key,
            crdtId: this.crdtId
          });
        }
        _results = [];
        for (_i = 0, _len = delProps.length; _i < _len; _i++) {
          delProp = delProps[_i];
          delProp.deleted = true;
          _results.push(_.indexOf(this._properties, delProp));
        }
        return _results;
      }
    };

    _CrdtDocument.prototype._setDeleted = function(index, forKey, deleted) {
      var prop;
      if (index >= this._properties.length) {
        Meteor.log["throw"]('crdt.tryingToUnDeleteNonexistentIndex', {
          index: index
        });
      }
      prop = this._properties[index];
      if (prop.deleted === deleted) {
        Meteor.log.warning('crdt.tryingToUnDeleteIndexInVisibleEntry', {
          index: index
        });
      }
      if ((forKey != null) && prop.payload.key !== forKey) {
        Meteor.log["throw"]('crdt.tryingToUnDeleteIndexWithWrongKey', {
          index: index,
          actualKey: prop.payload.key,
          shouldKey: forKey
        });
      }
      prop.deleted = deleted;
      return index;
    };

    _CrdtDocument.prototype.deleteIndex = function(index, forKey) {
      if (forKey == null) {
        forKey = null;
      }
      return this._setDeleted(index, forKey, true);
    };

    _CrdtDocument.prototype.undeleteIndex = function(index, forKey) {
      if (forKey == null) {
        forKey = null;
      }
      return this._setDeleted(index, forKey, false);
    };

    _CrdtDocument.prototype.serialize = function() {
      return {
        crdtId: this.crdtId,
        clock: this.clock,
        properties: this._properties,
        deleted: this._deleted
      };
    };

    _CrdtDocument.prototype.snapshot = function() {
      var collKey, collSpec, key, prop, snapshot, subkey, value, _i, _len, _ref, _ref1, _ref2, _ref3;
      if (this._deleted) {
        return null;
      } else {
        snapshot = {
          _id: this.crdtId
        };
        _ref = this._properties;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          prop = _ref[_i];
          if (!(!prop.deleted)) {
            continue;
          }
          _ref1 = prop.payload, key = _ref1.key, value = _ref1.value;
          switch ((_ref2 = this.collProps[key]) != null ? _ref2.type : void 0) {
            case '[*]':
              if (snapshot[key] == null) {
                snapshot[key] = [];
              }
              snapshot[key].push(value);
              break;
            case '[{}]':
              subkey = value[this.collProps[key].locator];
              if (snapshot[key] == null) {
                snapshot[key] = {};
              }
              snapshot[key][subkey] = value;
              break;
            default:
              snapshot[key] = value;
          }
        }
        _ref3 = this.collProps;
        for (collKey in _ref3) {
          collSpec = _ref3[collKey];
          if (collSpec.type = '[{}]') {
            snapshot[collKey] = _.values(snapshot[collKey]);
          }
        }
        return snapshot;
      }
    };

    return _CrdtDocument;

  })();

}).call(this);
