// Generated by CoffeeScript 1.4.0
(function() {

  Meteor._TransactionsManager = (function() {

    function _TransactionsManager() {
      var abort, addPending, crdtManager, currentOps, doTransaction, execute, getTick, getTxId, happenedBefore, localSite, pendingTxs, queueInternal, redoStack, ticTac, transactions, undoStack,
        _this = this;
      if (Meteor.isServer) {
        localSite = 'server';
      } else {
        localSite = 'client-' + Meteor.uuid();
      }
      pendingTxs = [];
      undoStack = [];
      redoStack = [];
      currentOps = [];
      getTick = function(clock, site) {
        if (clock[site] == null) {
          clock[site] = 0;
        }
        return clock[site];
      };
      ticTac = function(clock) {
        if (clock == null) {
          clock = {};
        }
        clock[localSite] = (getTick(clock, localSite)) + 1;
        return clock;
      };
      happenedBefore = function(clock1, clock2) {
        var clockComponent1, clockComponent2, didHappenBefore, site, sites, _i, _len;
        sites = _.union(_.keys(clock1), _.keys(clock2));
        didHappenBefore = false;
        for (_i = 0, _len = sites.length; _i < _len; _i++) {
          site = sites[_i];
          clockComponent1 = getTick(clock1, site);
          clockComponent2 = getTick(clock2, site);
          if (clockComponent1 > clockComponent2) {
            return false;
          }
          if (clockComponent1 < clockComponent2) {
            didHappenBefore = true;
          }
        }
        return didHappenBefore;
      };
      getTxId = function(tx) {
        if (tx._id != null) {
          return tx._id;
        } else {
          return 'simulated';
        }
      };
      crdtManager = Meteor._CrdtManager;
      addPending = function(tx) {
        var baseClock, crdt, lastClock, op, opClock, outOfOrder, txId, txSite, _i, _len, _ref;
        txId = getTxId(tx);
        txSite = tx.initiatingSite;
        outOfOrder = false;
        _ref = tx.operations;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          op = _ref[_i];
          opClock = op.clock;
          baseClock = _.clone(opClock);
          baseClock[txSite] = (getTick(opClock, txSite)) - 1;
          console.assert(baseClock[txSite] >= 0);
          op.baseClock = baseClock;
          crdt = crdtManager.findCrdt(op.collection, op.crdtId);
          lastClock = crdt != null ? crdt.clock : {};
          if (happenedBefore(baseClock, lastClock)) {
            Meteor.log.error('transaction.receivedDuplicateTx', {
              site: txSite,
              tx: txId
            });
            return false;
          }
          if (happenedBefore(lastClock, baseClock)) {
            outOfOrder = true;
          }
        }
        if (outOfOrder) {
          Meteor.log.warning('transaction.arrivedOutOfOrder', {
            site: txSite,
            tx: txId
          });
        }
        return pendingTxs.push(tx);
      };
      abort = function(tx) {
        var txId;
        txId = getTxId(tx);
        Meteor.log.warning('transaction.aborting', {
          tx: txId
        });
        return crdtManager.txAbort();
      };
      doTransaction = function(tx) {
        var args, op, txId, _i, _len, _ref;
        txId = getTxId(tx);
        crdtManager.txStart();
        _ref = tx.operations;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          op = _ref[_i];
          try {
            args = op.args != null ? op.args : {};
            op.result = crdtManager[op.op](op.collection, op.crdtId, args, op.clock);
          } catch (e) {
            Meteor.log.error('transaction.operationProducedError', {
              op: op.op,
              tx: txId,
              message: _.isString(e) ? e : e.message
            });
            abort(tx);
            return false;
          }
        }
        crdtManager.txCommit();
        return true;
      };
      execute = function(tx) {
        var crdt, executableTx, i, initiatingSite, lastClock, op, pendingTx, _i, _j, _len, _len1, _ref;
        addPending(tx);
        while (true) {
          executableTx = null;
          for (i = _i = 0, _len = pendingTxs.length; _i < _len; i = ++_i) {
            pendingTx = pendingTxs[i];
            executableTx = pendingTx;
            _ref = pendingTx.operations;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              op = _ref[_j];
              crdt = crdtManager.findCrdt(op.collection, op.crdtId);
              lastClock = crdt != null ? crdt.clock : {};
              if (happenedBefore(lastClock, op.baseClock)) {
                executableTx = null;
                break;
              }
            }
            if (executableTx != null) {
              pendingTxs.splice(i, 1);
              break;
            }
          }
          if (executableTx == null) {
            return true;
          }
          initiatingSite = executableTx.initiatingSite;
          Meteor.log.info('transaction.nowExecuting', {
            site: initiatingSite,
            tx: getTxId(executableTx)
          });
          if (!doTransaction(executableTx)) {
            return false;
          }
          if (initiatingSite === localSite && !executableTx.isUndo) {
            undoStack.push(executableTx.operations);
          }
        }
      };
      this.undo = function() {
        var originalOperation, undoOperations, undoTx, _i, _len, _ref;
        if (undoStack.length === 0) {
          Meteor.log.info('transaction.nothingToUndo');
          return;
        }
        undoTx = undoStack.pop();
        undoOperations = [];
        _ref = (undoTx.slice(0)).reverse();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          originalOperation = _ref[_i];
          undoOperations.push({
            op: 'inverse',
            collection: originalOperation.collection,
            crdtId: originalOperation.crdtId,
            args: {
              op: originalOperation.op,
              args: originalOperation.args,
              result: originalOperation.result
            }
          });
        }
        queueInternal(undoOperations, true);
        return redoStack.push(undoTx);
      };
      this.redo = function() {
        var redoTx;
        if (redoStack.length === 0) {
          Meteor.log.info('transaction.nothingToRedo');
          return;
        }
        redoTx = redoStack.pop();
        return queueInternal(redoTx);
      };
      this._addOperation = function(operation) {
        return currentOps.push(operation);
      };
      this.rollback = function() {
        return currentOps = [];
      };
      this.commit = function() {
        redoStack = [];
        queueInternal(currentOps);
        return currentOps = [];
      };
      if (Meteor.isServer) {
        transactions = new Meteor.Collection('transactions');
        this.purgeLog = function() {
          return transactions.remove({});
        };
      }
      Meteor.methods({
        _executeTx: function(tx) {
          if (!this.isSimulation) {
            tx._id = transactions.insert(tx);
          }
          return execute(tx);
        }
      });
      queueInternal = function(operations, isUndo) {
        var crdt, op, tx, _i, _len;
        if (isUndo == null) {
          isUndo = false;
        }
        for (_i = 0, _len = operations.length; _i < _len; _i++) {
          op = operations[_i];
          crdt = crdtManager.findCrdt(op.collection, op.crdtId);
          op.clock = ticTac(crdt != null ? crdt.clock : void 0);
        }
        tx = {
          initiatingSite: localSite,
          isUndo: isUndo,
          operations: operations
        };
        return Meteor.call('_executeTx', tx);
      };
    }

    return _TransactionsManager;

  })();

  Meteor._TransactionsManager = new Meteor._TransactionsManager;

  Meteor.tx = Meteor._TransactionsManager;

}).call(this);
